
## 软件定义及特征?

**定义**：软件=程序+数据+文档

软件是：

(1)     指令的集合（计算机程序），通过执行这些指令可以满足预期的特性、功能和性能需求；

(2)     数据结构，使得程序可以合理利用信息；

(3)     软件描述信息，它以硬拷贝和虚拟形式存在，用来描述程序的操作和使用。

**特征**：软件不会磨损，但是软件退化确实存在

解释：

- (1)软件是逻辑的而非物理的系统元素，区别于硬件，不会“磨损”，也不会被引起硬件磨损的环境问题所影响；
- (2)磨损的硬件部件可以用备用部件替换，而软件却不存在备用部件，每个软件的缺陷都暗示了设计的缺陷或者在从设计转化到机器可执行代码的过程中产生的错误；
- (3)不断的变更是软件退化的根本原因，软件维护要应对变更请求，比硬件维护更为复杂。

## 软件生存周期

**软件工程**：将系统化的、规范的、可量化的方法应用于软件的开发、运行和维护，即将工程化方法应用于软件。

补充：软件工程是一种层次化技术

(1)   支持软件工程的根基在于**质量关注点**(quality focus)；

(2)   软件工程的基础是**过程**(process)层；

(3)   软件工程**方法**(method)为构建软件提供技术上的解决方法；

(4)   软件工程**工具**(tool)为过程和方法提供自动化或半自动化的支持。

## 软件过程的五种框架活动?

软件过程是工作产品构建时所执行的一系列**活动**、**动作**和**任务**的集合。

五种框架活动：**沟通**、**策划**、**建模**、**构建**、**部署**

## 说明软件过程流的各个类型?

过程流描述了在执行顺序和执行时间上如何组织框架中的活动、动作和任务。

- **线性过程流**(linear process flow)从沟通到部署顺序执行五个框架活动；

- **迭代过程流**(iterative process flow)在执行下一个活动前重复执行之前的一个或多个活动；

- **演化过程流**(evolutionary process flow)采用循环的方式执行各个活动，每次循环都能产生更为完善的软件版本；

- **并行过程流**(parallel process flow)将一个或多个活动与其他活动并行执行（例如，软件一个方面的建模活动可以与软件另一个方面的构建活动并行执行）。

![[./image/Pasted image 20250615214959.png]]

## 软件生存周期

### 计划时期

- 问题定义
- 可行性分析

主要任务：**调查**和**分析**

### 开发时期

主要任务：**设计**和**实现**

设计：
- 需求分析
- 软件设计

开发：
- 编码
- 测试

#### 需求分析

- 功能 
- 性能
- 设计的限制
- 软件与其他系统元素的接口
- 其他有效性需求

**需求规格说明书**

#### 软件设计

主要任务：把各项需求转化为**体系结构**

- 总体设计
- 详细设计

#### 编码

源程序清单

#### 测试

发现问题，而非证明没有问题

### 运行时期

主要工作：软件维护

## 软件生存周期模型

一般都包含**定义**（What）、**开发**（How）和**维护**（Change）。

### 瀑布模型

#### 计划时期

- 问题定义
- 可行性分析
- 需求分析

#### 开发时期

- 概要设计
- 详细设计
- 软件实现
- 软件测试

#### 运行时期

- 运行维护

缺点：不灵活，难调整

### 演化模型

### 螺旋模型

## 可行性研究

### 任务

- 经济可行性
- 技术可行性
- 法律可行性
- 运行可行性

### 步骤

1. 确定系统的规模和目标
2. 分析现有系统，设计新系统的高层系统模型
3. 评审系统模型
4. 设计和评价新系统的实现方案
5. 指定行动方案
6. 拟定开发计划
7. 编制可行性报告

### 工具

#### 系统流程图

只描述信息在系统各部件中的流动情况

![[./image/Pasted image 20250615155642.png]]

### 制定项目计划

## 敏捷原则

**(1)**      **敏捷开发宣言**

“个人和他们之间的交流胜过开发过程和工具，可运行的软件胜过宽泛的文档，客户合作胜过合同谈判，对变更的良好响应胜过按部就班地遵循计划”

**(2)**      **敏捷开发**

**简述：**

l 是由客户对他们的需求的描述（场景）所驱动的

l 意识到计划是短期的

l 着重强调构建活动的软件迭代开发

l 交付多个软件增量

l 适应变更的出现

**(3)**      **12条原则**

**简述：**

1. 通过尽快向客户交付软件来提供价值，可以获得客户满意度

2. 敏捷团队由积极进取的个人组成，他们面对面交流，在有利于高质量软件开发的环境中工作

3. 敏捷团队是一个“自我组织团队”，能够开发结构良好的体系结构，从而实现可靠的设计并达到客户满意度

4. 并不是每一个敏捷过程模型都要同等地使用这些特征，一些模型可以选择忽略（或至少淡化）一项或多项原则的重要性

**详细：**

1. 我们最重要的目标，是通过持续不断地及早交付有价值的软件使客户满意

2. 欣然面对需求变化，即使在开发后期也一样。为了客户的竞争优势，敏捷过程掌控变化

3. 经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期

4. 业务人员和开发人员必须相互合作，项目中的每一天都不例外

5. 激发个体的斗志，以他们为核心搭建项目。提供所需的环境和支援，辅以信任，从而达成目标

6. 不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈

7. 可工作的软件是进度的首要度量标准

8. 敏捷过程倡导可持续开发。责任人、开发人员和用户要能够共同维持其步调稳定延续

9. 坚持不懈地追求技术卓越和良好设计，敏捷能力由此增强

10. 以简洁为本，它是极力减少不必要工作量的艺术

11. 最好的架构、需求和设计出自自组织团队

12. 团队定期地反思如何能提高成效，并依此调整自身的举止表现

## 需求分析

- 功能 
- 性能
- 设计的限制
- 软件与其他系统元素的接口
- 其他有效性需求

基本任务：一起完全弄清用户对系统的确切要求

解决“系统做什么”，但不包括“怎么做”。

具体任务：

1. 确定目标系统的具体要求
	1. 确定系统的运行环境要求
	2. 系统的性能要求
	3. 系统功能
2. 分析系统的数据要求
3. 建立目标系统的逻辑模型
4. 修正系统开发计划
5. 建立原型系统
6. 编写**软件需求规格说明书**以及评审

## 简述需求建模的模型?

需求分析的元素

1. 基于场景的模型
2. 类模型
3. 行为模型
4. 流模型

**(1)**     **场景模型**

- 出自各种系统“参与者”观点的需求

- **做什么**：从不同“参与者”（Actor，如读者、管理员、系统）视角，刻画他们和系统的交互流程。
- **示例**：
    - 用例：读者借书
    - 步骤：读者→查图书→发出借书请求→系统检查库存→系统确认借出→读者收到借书凭证

**(2)**     **数据模型**

- 描述问题信息域的模型

- **做什么**：定义要处理的信息是什么，信息之间有什么关系。
- **示例**（简化 ER 图）：
    - **实体**：Reader（读者）、Book（图书）、LoanRecord（借阅记录）
    - **关系**：Reader “借阅” Book（多对多，通过 LoanRecord 关联）

**(3)**     **面向类的模型**

- 表示面向对象类（属性和操作）的模型，方式为通过类的协作者获得系统需求

- **做什么**：把系统抽象成“类”——每个类有什么属性（数据）和操作（方法），以及彼此协作关系
- **示例**（简化 UML 类图）：

```txt
+----------------+       +-------------------+
|    Reader      |       |      Book         |
|– readerId      |       |– bookId           |
|– name          |       |– title            |
|+ borrowBook()  |◀──────|+ updateInventory()|
+----------------+       +-------------------+
          │
          ▼
    +-------------+
    | LoanRecord  |
    |– loanId     |
    |– dueDate    |
    |+ calculateFine()|
    +-------------+
```

**(4)**     **面向流的模型**

- 表示系统的功能元素并且描述当功能元素在系统中运行时怎样进行数据变换
- **做什么**：从功能块（function）和数据流（data flow）的角度，描述系统内部信息如何移动和转换。
- **示例**（简化数据流图 DFD）：
```txt
[Reader] --(borrow request)--> (Check Inventory) --(available?)--> (Create LoanRecord) --> [Database]
```

**(5)**     **基于行为和模式的模型**

- 描述如何将软件行为看作外部“事件”后续的模型
- **做什么**：刻画系统或对象在不同事件（Event）驱动下如何变化（状态图）或如何通过设计模式协作（Sequence Diagram / Collaboration Diagram）。
- **示例**：
    - **状态图**：LoanRecord 从“待借出”→“已借出”→“已归还”
    - **时序图**：读者发出借书请求→系统校验→库存服务→更新记录→返回结果

## 一、描述CRC模型的评审步骤

1. **分发卡片，避免重复**：所有参加（CRC模型）评审的人员拿到一部分CRC模型索引卡。每个评审员不能有两张存在协作关系的卡片。

2. **把用例和用例图都准备好**：分类管理所有的用例场景（以及相关的用例图）。

3. **组长阅读用例，分发令牌**：评审组长细致地阅读用例。当评审组长看到一个已命名的对象时，给拥有相应类索引卡的人员一个令牌。

4. **持卡人描述职责，团队核对**：当令牌传递时，该类卡的拥有者需要描述卡上记录的职责。评审组确定（一个或多个）职责是否满足用例需求。

5. **发现问题就改卡片**：如果发现错误，则对索引卡进行修改。修改可能包括定义新类（和相关的CRC索引卡），或者在已有的卡上修改职责和协作列表。

## 描述行为建模的步骤?

(1)   评估所有的用例，以保证完全理解系统内的交互顺序；

(2)   识别驱动交互顺序的事件，并理解这些事件如何与特定的对象相互关联；

(3)   为每个用例生成序列；

(4)   创建系统状态图；

(5)   评审行为模型以验证准确性和一致性。

![[./image/Pasted image 20250615221811.png]]

## 结构化分析方法SA

![[./image/Pasted image 20250615130528.png]]

### 确定具体要求

### 建立逻辑模型

**结构分析**

- 核心思想：自顶向下，逐步求精
- 基本原则：抽象与分解
- 特点：简单实用，但不适合规模大的复杂项目
- 内容：
	- 功能模型：
		- **数据流程图**（DFD）
			- 设计思想：
				- 自顶向下、逐层分解、先整体后局部
				- 子图和父图需要保持输入与输出的一致
				- ![[./image/Pasted image 20250615162432.png]]
		- 数据字典（DD）
			- 内容：
				- 数据项、数据结构、数据流、处理逻辑、数据存储、外部实体
				- 通常以卡片形式给出：数据流卡、数据存储卡、数据处理卡、数据元素卡
	- 数据模型
		- **E-R 图**
			- 作用：描述客观世界中实体、实体属性和实体间的关系
			- 图形符号：
				- 矩形 $\to$ 实体
				- 椭圆形 $\to$ 实体的属性
				- 菱形 $\to$ 实体间的联系
			- ![[./image/Pasted image 20250615163005.png]]
	- 行为模型
		- **状态转换图**（STD）
			- 作用：用于呈现数据对象在不同状态下的不同行为方式
			- 相关概念：
				- 状态：系统的行为模式，包括初态、终态、中间状态
				- 事件： 在某个时刻发生的事情，使得系统从一个状态转移到另一个状态
				- 状态迁移：一个状态向另一个状态的转换。在图中用箭头指向最终转换的状态。

**面向对象分析**

**核心思想**：利用面向对象的概念和方法，建立软件需求模型，使用户需求逐步精确化、一致化、完全化。

**内容**：
- 功能模型
	- **UML 用例图**
		- 作用：用**参与者**、**用例**以及他们的**关系**来描述系统功能的视图。
		- **参与者**：与系统交互的外部实体。**小人**
			- 直接用户（谁用系统）
			- 外部系统/设备（谁和系统互动）
			- 关键流程中的角色（谁在流程中起作用）
			- 参与者之间的主要关系：**泛化**，更强调一种继承性。
		- **用例**：系统能为用户提供的具体功能。**实线椭圆**
			- 一个用例就是系统为用户提供的一个具体功能。
			- 明确系统边界
			- 找到参与者
			- 确定参与者的目标
			- 归纳互动场景
			- 整理用例
			- **泛化关系**：表示用例间的继承关系（空心箭头，指向父母）
			- **包含关系**：一个功能在执行时，必须包含另一个用例。（虚线箭头，<<\include>>，指向被包含用例）
			- **拓展关系**：A 用例有时会用到 B，但不是每次都用，而是满足某些条件时才会执行，A 是被拓展用例，B 是拓展用例。（虚线箭头，<<\extend>>，指向被拓展用例）
- 对象模型
	- 类图
- 动态模型
	- 时序图
	- 活动图
	- 状态转化图

### 编写需求文档，确认需求
## 软件设计

![[./image/Pasted image 20250615223602.png]]

## 如何描述模块功能独立性?

功能独立的概念是关注点分离、模块化、抽象和信息隐蔽概念的产物。通过开发具有“专一”功能和“避免”与其他模块过多的交互模式，可以实现功能独立。

**评估标准**

(1) 内聚性显示了某个模块相关功能的强度。一个内聚的模块执行一个独立的任务，与程序的其他部分构建只需要很少的交互。简单地说，一个内聚的模块应该只能完成一件事情。

![[./image/Pasted image 20250616100834.png]]

(2) 耦合性显示了模块间的相互依赖性。耦合性依赖于模块间的接口复杂性、引用或进入模块所在的点以及什么数据通过接口信息传递。

![[./image/Pasted image 20250616100856.png]]

## 重构的特点及要点?

- **定义**：重构是使用这样一种方式改变软件系统的过程：不改变代码（设计）的外部行为而是改进其内部结构。

- **重构要点**：在重构软件时，检查现有设计的冗余性、没有使用的设计元素、低效的或不必要的算法、拙劣或不恰当的数据结构以及其他设计不足，修改这些不足以获得更好的设计。

## 描述体系结构风格的四个要素及其分类?

**1.** 体系风格描述4要素：

**(1)** 一组执行系统所需功能的**构件**（例如，数据库、计算模块）

- 系统要“做什么”，由一组构件来完成。

**(2)** 一组实现构件间“通信、合作和协调”的**连接件**；

- 构件之间如何**通信与协作**的机制。

**(3)** 定义构件如何集成为系统的**约束**；

**(4)** 能够使设计者通过分析系统组成元素的已知属性来理解系统整体性质的**语义模型**。
- 

**2.** **风格分类：**

(1) **以数据为中心的体系结构**

- 例子：传统的客户端/服务器（Client–Server）、数据仓库（Data Warehouse）。

(2) **数据流体系结构**

- 例子：图像处理管道（读取→滤波→变换→输出），或 Unix 管道 `cmd1 | cmd2 | cmd3`。

(3) **调用和返回体系结构**

- 典型的过程式程序结构：一个模块调用另一个模块，再返回结果。
- 例子：函数调用、传统的三层（Presentation→Business→Data）结构。


(4) **面向对象的体系结构**

- 以对象为基本单元，封装了数据和操作，按职责分布在不同类/组件里，通过消息或方法调用协作。
- 例子：MVC（Model-View-Controller）、Domain-Driven Design（DDD）。

(5) **层次体系结构**

- 将系统按功能划分为若干层，每层只和相邻层交互。
- 例子：OSI 七层网络模型、Web 应用的前端（UI 层）、服务层、持久层。

### 概要设计

作用：确定构成系统的模块以及其层次结构

原则：
- 从宏观到微观、逐步求精、使用模块化方法
- 模块规模要适中，大小要适当
- 高内聚、低耦合：紧密程度
	- 内聚
	- 耦合
- 模块的层次结构
	- **结构图**（SC）
	- ![[./image/Pasted image 20250615183737.png]]
	- 深度：模块控制的层数
	- 宽度：统一层次的模块总数
	- 扇出
	- 扇入

**功能结构图**（HIPO）

作用：反映一个软件的各组成部分及模块之间的关系

设计方法：数据流程图映射法

![[./image/Pasted image 20250615184849.png]]

**模块图**（IPO）

作用：给每个模块的具体功能提供依据，依据是输入、处理、输出的详细描述。

设计方法：

![[./image/Pasted image 20250615185333.png]]

**面向对象设计**（OOD）

- 作用：将前面需求分析中的面向对象分析（OOA）所创建的分析模型转换为设计模型
- 面向对象模型

准则：
- 抽象
- 信息屏蔽：用类实现封装，对内部细节实现保护
- 高内聚
- 低耦合
- 可重用

**类图**

作用：描述类、接口、协同以及他们之间的关系

由类、接口和各种关系组成

关系：泛化、依赖、关联、实现
- 依赖关系
- ![[./image/Pasted image 20250615193320.png]]
- 泛化关系
- ![[./image/Pasted image 20250615193350.png]]
- 关联关系
- ![[./image/Pasted image 20250615193519.png]]
- 实现关系

构成：名称、属性、操作、职责、约束、注释
- 属性：可见性（+、-、#、~）、属性名称
- 操作

**部署图**

节点：
- 处理器
- 设备
关系：

### 详细设计

#### 图形工具

**程序流程图**

![[./image/Pasted image 20250615195852.png]]

![[./image/Pasted image 20250615195932.png]]

**结构流程图**

**盒图/N-S图**

控制结构

![[./image/Pasted image 20250615200018.png]]

**问题分析图**（PAD）

![[./image/Pasted image 20250615200313.png]]

判定表

判定树

**序列图**

- 对象
- 生命线：与时间轴平行
- 消息
- ![[./image/Pasted image 20250615201048.png]]
- 激活
- ![[./image/Pasted image 20250615201115.png]]
- ![[./image/Pasted image 20250615201153.png]]

**活动图**

![[./image/Pasted image 20250615201405.png]]

![[./image/Pasted image 20250615201451.png]]

![[./image/Pasted image 20250615201517.png]]

![[./image/Pasted image 20250615201536.png]]

![[./image/Pasted image 20250615201551.png]]

![[./image/Pasted image 20250615201614.png]]

![[./image/Pasted image 20250615201647.png]]

![[./image/Pasted image 20250615201720.png]]

## 用户体验设计的黄金三原则

**1.** **把控制权交给用户**

(1) 以不强迫用户进入不必要的或不希望的动作的方式来定义交互模式；

(2) 提供灵活的交互；

(3) 允许用户交互被中断和撤销；

(4) 当技能水平高时可以使交互流线化并允许定制交互；

(5) 使用户与内部技术细节隔离开来；

(6) 设计应允许用户与出现在屏幕上的对象直接交互。

**2.** **减轻用户的记忆负担**

(1) 减少对短期记忆的要求；

(2) 建立有意义的默认设置；

(3) 定义直观的快捷方式；

(4) 界面的视觉布局应该基于真实世界的象征；

(5) 以一种渐进的方式揭示信息。

**3.** **保持界面一致**

(1) 允许用户将当前任务放入有意义的环境中；

(2) 在完整的产品线内保持一致性；

(3) 如果过去的交互模型已经建立起了用户期望，除非有不得已的理由，否则不要改变它。

## 宏观描述软件测试步骤

(1) **单元测试**。侧重于以源代码形式实现的每个**单元**（例如，构件、类或WebApp内容对象）；

(2) **集成测试**。这时的测试重点在于**软件体系**结构的设计和构建；

(3) **确认测试**。在这个阶段，依据已经建立的软件，对**需求**（作为软件需求建模的一部分而建立）进行确认；

(4) **系统测试**。将**软件与系统的其他成分**作为一个整体来测试。

- 指“整个系统在真实或接近真实的环境中测试”。

![[./image/Pasted image 20250615231223.png]]

## 桩模块、驱动模块的作用

由于构件并不是独立的程序，需要不同类型的“脚手架”来创建测试框架。作为测试框架的组成部分，必须为每个测试**单元**开发驱动程序和桩程序。

**(1)** **驱动程序**只是一个“主程序”，它接受测试用例数据，将这些数据传递给（将要测试的）构件，并打印相关结果。

**(2)** **桩程序**的作用是替换那些从属于被测构件（或被其调用）的模块。**桩程序**或“伪程序”使用从属模块的接口，可能做少量的数据操作，提供入口的验证，并将控制返回到被测模块。

![[./image/Pasted image 20250615232550.png]]

## 自顶向下集成测试步骤?

1. 主控模块用作测试驱动模块，用直接从属于主控模块的所有模块代替桩模块。

2. 依靠所选择的集成方法（深度优先或广度优先），每次用实际模块替换一个从属桩模块。

3. 集成每个模块后都进行测试。

4. 在完成每个测试集之后，用实际模块替换另一个桩模块。

5. 可以执行回归测试以确保没有引入新的错误。

回到第2步继续执行此过程，直到完成了整个程序结构的构建

![[./image/Pasted image 20250615233253.png]]

## 软件测试

### 概述

- 作用：发现程序错误，衡量软件质量
- 过程：自底向上，逐步集成
- ![[./image/Pasted image 20250615201956.png]]
- 目的：尽可能多的找到软件中隐藏的错误，而不是证明软件的正确性

### 黑盒测试

特点：只需要知道被测软件的界面和接口外部情况，不必考虑程序内部逻辑结构和特性。

方法：

- 等价类划分法
	- 划分等价类
		- 有效等价类
		- 无效等价类
	- 选取测试用例
		- ![[./image/Pasted image 20250615202842.png]]
		- ![[./image/Pasted image 20250615203446.png]]
- 边界值分析
- ![[./image/Pasted image 20250615203659.png]]
- 因果图
- ![[./image/Pasted image 20250615203738.png]]

### 白盒测试

以程序内部的逻辑结构为基础来设计测试用例，主要用于单元测试。

**基本概念**

![[./image/Pasted image 20250615204236.png]]

**逻辑覆盖测试**

![[./image/Pasted image 20250615204518.png]]


## 软件基线、SCI、项目数据库画图说明?

**基线定义**：已经通过正式评审和批准的规格说明或产品，它可以作为进一步开发的基础，并且只有通过正式的变更控制规程才能修改它。

**SCI（Software Configuration Item）**：一切要纳入版本管理的“配置项”，如：需求文档、设计模型、源码、测试脚本、运行包。

![[./image/Pasted image 20250615235005.png]]

![[./image/Pasted image 20250615234948.png]]

## 构建团队的七个因素?

(1) 待解决问题的难度；

(2) 开发程序的规模，以代码行或者功能点来度量；

(3) 团队成员需要共同工作的时间（团队生存期）；

(4) 能够对问题做模块化划分的程度；

(5) 待开发系统的质量要求和可靠性要求；

(6) 交付日期的严格程度；

(7) 项目所需要的友好交流的程度。

## 团队毒性的因素及如何避免?

**因素：**

(1) 狂乱的工作氛围；

(2) 引起团队成员间产生摩擦的重大挫折；

(3) “碎片式的或协调很差”的软件过程；

(4) 在软件团队中没有清晰的角色定义；

(5) “接连不断地重蹈覆辙”。

**解决方法：**

(1) 为了避免狂乱的工作环境，项目经理应该确保团队可以获取完成工作所需的所有信息；而且，主要目标一旦确定下来，除非绝对必要，否则不应该修改。

(2) 给予软件团队尽可能多的决策权，这样能使团队避免挫败。

(3) 通过理解将要开发的产品和完成工作的人员，以及允许团队选择过程模型，可以避免选择不适当的软件过程（如不必要的或繁重的工作任务，或没有很好地选择工作产品）。

(4) 团队本身应该建立自己的责任机制（技术评审是实现此目标的极好方式），并规定一系列当团队成员未能完成任务时的纠正方法。

(5) 最后，避免失败的关键是建立基于团队的信息反馈方法和解决问题的技术。

## 一、 4P是什么?

- **人**(People)——成功项目的最重要元素。

- **产品**(Product)——要构建的软件。

- **过程**(Process)——完成工作的一系列框架活动和软件工程任务。

- **项目**(Project)——使产品成为现实所需的所有工作。

二、 团队负责人五种特质?

(1) **以身作则**。领导者必须按他们所说的那样去做。他们通过共同牺牲来展现自己为团队和项目所做的贡献（例如，成为每晚最后一个回家的人或花时间成为软件应用方面的专家）。

(2) **共启愿景**。领导者意识到他们无法在没有追随者的情况下领导。激励团队成员将他们的个人抱负和团队目标联系起来是十分重要的。这意味着在设定目标过程中尽早让利益相关者参与。

(3) **挑战现状**。领导者必须主动寻找创新方法，来改进自身的工作和团队的工作。通过帮助团队成员从失败中吸取教训的同时经常创造一些小成功，来鼓励他们去尝试和冒险。

(4) **使他人行**。通过建立信任和促进关系来培养团队的协作能力。通过分享决策和目标设定来提高团队的胜任感。

(5) **鼓舞人心**。庆祝个人的成就。通过庆祝团队内外的共同目标和胜利来建立团体（团队）精神。

## 5W2H原则?

l **为什么**（Why）要开发这个系统？所有利益相关者都应该了解软件工作的商业理由是否有效。该系统的商业目的值得花费这些人力、时间和金钱吗？

l **将要做什么**（What）？定义项目所需的任务集。

l **什么时候**（When）做？团队制定项目进度，标识出何时开展项目任务以及何时到达里程碑。

l 某功能由**谁**（Who）负责？规定软件团队每个成员的角色和责任。

l 他们的机构组织位于**何处**（Where）？并非所有角色和责任均属于软件团队，客户、用户和其他利益相关者也有责任。

l **如何**（How）完成技术工作和管理工作？一旦确定了产品范围，就必须定义项目的管理策略和技术策略。

l 每种资源需要**多少**（How much）？对这个问题，需要在对前面问题回答的基础上通过估算而得到。

## 软件项目管理

![[./image/Pasted image 20250615204648.png]]
