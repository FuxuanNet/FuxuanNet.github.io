# 视图

## 视图的特点

- 虚表：是从一个或几个基本表（或视图）导出的表
- 只存放视图的定义，不存放视图对应的数据
- 基表中的数据发生变化，从视图中查询出的数据也随之改变

## 定义视图

> 为什么没有介绍修改操作？
> 
> 视图啊是在基本表上建立出了一个映射关系，它本身还不存放数据，数据还是人家基本表投射出来的，那我如果有功夫去修改你的这个映射关系，我为什么不把你删了重新建一个呢？我是不是更加的直观？所以啊这个视图并不给大家提供修改功能。
> 
> 那不是说完全不能修改，改的是什么呢？改的可以是视图的名，别的都不能让你改了啊。
> 
> 所以大家掌握好这个思路，就是视图之类的东西，你要改不如把它删了重新建来的方便。

### 建立视图

#### 语句格式

```sql
CREATE VIEW
	<视图名> [(<列名> [,<列名>]...)]
AS <子查询>
[WITH CHECK OPTION]
```

- `<WITH CHECK OPTION>`
	- 对视图进行 `UPDATE`, `INSERT` 和 `DELETE` 操作时要保证更新、插入或删除的行满足视图定义中的谓词条件（即子查询中的条件表达式）

#### 例子：建立计算机系学生的视图

```SQL
CREATE VIEW CS_STUDENT
AS
SELECT SNo, SName, Sage
FROM Student
WHERE Smajor='CS'
WITH CHECK OPTION; -- 删除和修改操作时仍保证视图只有计算机专业的学生则加上这一行
```

> 加上了之后进行插入、修改和删除操作时，RDBMS 会自动加上 `Smajor='CS` 的条件。

- 行列子集视图：若一个视图是从**单个基本表**导出的，并且只是去掉了基本表的某些行和某些列，但保留了**主码**，我们称这类视图为**行列子集视图**。

#### 例子：基于多个基表的视图

> 建立计算机系选修了 1 号课程的学生的视图。

```SQL
CREATE VIEW CS_S1(Sno, Sname, Grade)
AS
SELECT Student.Sno, Sname, Grade
FROM Student, SC
WHERE Smajor = 'CS' AND
	Student.Sno = SC.Sno AND -- 多表查询必须指定连接条件
	SC.Cno = '1'
```

#### 例子：基于视图的视图

> 建立计算机系选秀了 1 号课程且成绩在 90 分以上的学生的视图。

```SQL
CREATE VIEW CS_S2
AS
SELECT Sno, Sname, Grade
FROM CS_S1
WHERE Grade>=90;
```

#### 例子：分组视图

> 将学生的学号以及平均成绩定义为一个视图

```SQL
CREATE VIEW S_G(Sno, Gavg)
AS
SELECT Sno, AVG(Grade)
FROM SC
GROUP BY Sno
```

### 删除视图

#### 语句格式

```SQL
DROP VIEW <视图名>[CASCADE];
```

- 级联删除：如果**有其他对象（如其他视图）依赖于这个视图**，使用 `CASCADE` 会**自动删除所有依赖该视图的对象**。

## 查询视图

从用户角度来说，查询视图与查询基本表相同

而在 RDBMS 中实现视图查询的方法是视图消解法

- 进行有效性检查
- 转换成等价的对基本表的查询
- 执行修正后的查询

> 例子：在计算机系学生的视图中找出年龄小于 20 岁的学生。

```SQL
SELECT Sno, Sage
FROM CS_Student
WHERE Sage<20;
```

视图消解转换后的查询语句为：

```SQL
SELECT Sno, Sage
FROM Student
WHERE Smajor='CS' AND Sage<20;
```

## 更新视图

> 转换为对视图的基本表的更新

限制：一些视图是不可更新的，因为对这些视图的更新不能唯一地有意义地转换成对相应基本表的更新。（例如经过运算的平均分）

错误例子：

```SQL
UPDATE S_G
SET Gavg = 80
WHERE Sno = '2023065919'
```

这个视图的更新无法转换为对基本表 SC 的更新

## 视图的作用

- 视图能够简化用户的操作
- 视图使用户能以多种角度看待同一数据
- 视图对重构数据库提供了一定程度的逻辑独立性
- 视图能够对机密数据提供安全保护
- 适当的利用视图可以更清晰的表达查询
