---
title: 10正则表达式匹配
date: 2025-04-26
details: 编程基础 0 到 1
---

::: tip
给你一个字符串 `s` 和一个字符规律 `p`，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。

- `'.'` 匹配任意单个字符
- `'*'` 匹配零个或多个前面的那一个元素

所谓匹配，是要涵盖 **整个** 字符串 `s` 的，而不是部分字符串。
:::

## 引入

### 如何确定字符串是否和正则表达式匹配？

- 如果长度相等，就可以逐个比较每一位，若某位不等，就不能匹配

```txt
text    = abacac
pattern = abacbc
```

- 使用通配符`.` 代表能匹配任意字符。

```txt
text    = abacac
pattern = abac.c
```

- `*` 代表其前面的字符可以出现多次或不出现。

```txt
text    = aaaaaac
pattern = a*c
```

- 全部匹配

```txt
p = .*
```

### 复杂的例子

```txt
text    = aaa
pattern = ab*a*c*a
```

需要注意，我们必须要与最后一个字符匹配上。

所以中间的 `a*` 不可以把上面的 `aaa` 匹配完，只能匹配一个。

## 算法设计

### 函数定义

设一个函数，传入两个参数 $x$ 和 $y$，返回 `bool` 类型。

$$
F(x,\,y)=\text{true}\,|\,\text{false}
$$

- $x$ 代表从头选取 `text` 里的子串的长度。

- $y$ 代表从头选取 `pattern` 里子串的长度。

例如：

```txt
text    = aaa
pattern = ab*a*c*a
```

则 $F(2,\,5)$ 代表取 `text` 的 `aa` 和 `pattern` 的 `ab*a*`。

### 函数如何求解

#### 如果正则表达式最后一个字符不是星号

只需要比较两串的最后一个字符是否相等就可以了。

如果相等的话，那当前的状态就应该和上一次的状态相等，这样才可以匹配。

```python
if pattern(y) != `*`: # pattern(y) 指 pattern 长度为第 y 位的元素
	F(x, y) = F(x-1, y-1) if equals(x,y) # 最后元素相等
	F(x, y) = false if !equals(x,y) # 最后元素不等
else: # pattern(y) == `*`
```

#### 如果正则表达式最后一个字符是星号

星号必然和前一个字符视为一个整体。

例如：

```txt
pattern = ??????a*|||||||||||||
```

`a*` 应视为一个整体，代表着 `a` 可以出现 0 次或不出现。

##### 如果 * 前面的字符一次都不出现

就需要忽略 `a*`，让 `pattern` 向前越过两个字符，状态转移为 `y-2`:

```python
F(x, y)=F(x, y-2) if * no usage
```

那么伪代码如下：
```python
else: # pattern(y) == `*`
	F(x, y) = F(x, y-2)
```

##### 如果 * 前面的字符出现但是并不匹配当前选中的子串

也就是说，当前 text 所选的子串的最后一位并不等于 * 前面的字符时，那就也需要放弃 `a*`，表达式同上，修改如下：

```python
F(x, y)=F(x, y-2) if * no usage || !equals(x, y-1)
```

##### 如果 * 前面的字符可以和 x 最后一个字符匹配

```txt
text    = ????a|||||||||||
pattern = ??????a*||||||||
```

由于 `a*` 可以使用多次，所以相当于砍去 text 的最后一个字符，但是 `a*` 仍可以保持不变，状态转移为 `x-1`：

```python
F(x, y) = F(x-1, y) if equals(x, y-1)
```

那么最终的伪代码如下：
```python
else: # pattern(y) == `*`
	if equals(x, y-1): # 如果 * 前面的字符可以和 x 最后一个字符匹配
		F(x, y) = F(x-1, y)
	else: # 如果 * 前面的字符出现但是并不匹配当前选中的子串
		F(x, y) = F(x, y-2)
	# 如果 * 前面的字符一次都不出现
	F(x, y) =  F(x, y) || F(x, y-2) # 和上面*字符出现的结果取并集
```

### 伪代码

```python
if pattern(y) != `*`: # pattern(y) 指 pattern 长度为第 y 位的元素
	F(x, y) = F(x-1, y-1) if equals(x,y) # 最后元素相等
	F(x, y) = false if !equals(x,y) # 最后元素不等
else: # pattern(y) == `*` 正则表达式最后一个字符是星号
	if equals(x, y-1): # 如果 * 前面的字符可以和 x 最后一个字符匹配
		F(x, y) = F(x-1, y)
	else: # 如果 * 前面的字符出现但是并不匹配当前选中的子串
		F(x, y) = F(x, y-2)
	# 如果 * 前面的字符一次都不出现
	F(x, y) =  F(x, y) || F(x, y-2) # 和上面*字符出现的结果取并集
```

其中 `equals()` 函数表达的是，实现如下：

```python
boolean equals(x, y):
	if pattern(y) == '.':
		return true
	return text(x) == pattern(y)
```

其中 `text()` 和 `pattern()` 方法实现如下：

```python
char text(x):
	return text[x-1] # 这里原视频写的内容是 return text.charAt(x-1)

char pattern(y):
	return pattern[y-1]
```